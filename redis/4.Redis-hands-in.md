

# Redis Hands-in

> Redis On Kubernetes





# 1. Redis Install 준비

Bastion Server 에서 redis 를 설치해 보자.





## 1) helm chart

쿠버네티스에 서비스를 배포하는 방법이 다양하게 존재하는데 그중 대표적인 방법중에 하나가 Helm chart 방식 이다.



### (1) [참고] Helm Architecture



#### helm chart 의 필요성

일반적으로 Kubernetes 에 서비스를 배포하기 위해 준비되는 Manifest 파일은 정적인 형태이다. 따라서 데이터를 수정하기 위해선 파일 자체를 수정해야 한다.  잘 관리를 한다면 큰 어려움은 없겠지만, 문제는 CI/CD 등 자동화된 파이프라인을 구축해서 애플리케이션 라이프사이클을 관리할 때 발생한다.  

보통 애플리케이션 이미지를 새로 빌드하게 되면, 빌드 넘버가 변경된다. 이렇게 되면 새로운 이미지를 사용하기 위해 Kubernetes Manifest의 Image도 변경되어야 한다.  하지만 Kubernetes Manifest를 살펴보면, 이를 변경하기 쉽지 않다. Image Tag가 별도로 존재하지 않고 Image 이름에 붙어있기 때문입니다. 이를 자동화 파이프라인에서 변경하려면, sed 명령어를 쓰는 등의 힘든 작업을 해야 한다.

Image Tag는 굉장히 단적인 예제이다.  이 외에 도 Configmap 등 배포시마다 조금씩 다른 형태의 데이터를 배포해야 할때 Maniifest 파일 방식은 너무나 비효율적이다.  Helm Chart 는 이런 어려운 점을 모두 해결한 훌륭한 도구이다.  비단,  사용자가 개발한 AP 뿐아니라 kubernetes 에 배포되는 오픈소스 기반 솔루션들은 거의 모두 helm chart 를 제공한다.



#### Helm Architecture

![helm-architecure](redis-hands-in.assets/helm-architecure.png)



### (2) [참고] helm client download

helm client 를 local 에 설치해 보자.

개인PC 의 WSL Termimal 에서 아래 작업을 수행하자.

```sh
# root 권한으로 수행
$ su


## 임시 디렉토리를 하나 만들자.
$ mkdir -p ~/helm/
$ cd ~/helm/

# 다운로드
$ wget https://get.helm.sh/helm-v3.12.0-linux-amd64.tar.gz

# 압축해지
$ tar -zxvf helm-v3.12.0-linux-amd64.tar.gz

# 확인
$ ll linux-amd64/helm
-rwxr-xr-x 1 1001 docker 50597888 May 11 01:35 linux-amd64/helm*

# move
$ mv linux-amd64/helm /usr/local/bin/helm

# 확인
$ ll /usr/local/bin/helm*
-rwxr-xr-x 1 1001 docker 50597888 May 11 01:35 /usr/local/bin/helm*


# 일반유저로 복귀
$ exit


# 확인
$ helm version
version.BuildInfo{Version:"v3.12.0", GitCommit:"c9f554d75773799f72ceef38c51210f1842a1dea", GitTreeState:"clean", GoVersion:"go1.20.3"}


```



### (3) [참고] bitnami repo 추가

- 유명한 charts 들이모여있는 bitnami repo 를 추가후 nginx 를 배포해 보자.

```sh
# test# add stable repo
$ helm repo ls

# test# add stable repo
$ helm repo add bitnami https://charts.bitnami.com/bitnami

$ helm search repo bitnami
# bitnami 가 만든 다양한 오픈소스 샘플을 볼 수 있다.
NAME                                            CHART VERSION   APP VERSION     DESCRIPTION
bitnami/airflow                                 14.1.3          2.6.0           Apache Airflow is a tool to express and execute...
bitnami/apache                                  9.5.3           2.4.57          Apache HTTP Server is an open-source HTTP serve...
bitnami/appsmith                                0.3.2           1.9.19          Appsmith is an open source platform for buildin...
bitnami/argo-cd                                 4.7.2           2.6.7           Argo CD is a continuous delivery tool for Kuber...
bitnami/argo-workflows                          5.2.1           3.4.7           Argo Workflows is meant to orchestrate Kubernet...
bitnami/aspnet-core                             4.1.1           7.0.5           ASP.NET Core is an open-source framework for we...
bitnami/cassandra                               10.2.2          4.1.1           Apache Cassandra is an open source distributed ...
...

# 설치테스트(샘플: nginx)
$ helm -n user02 install nginx bitnami/nginx

$ ku get all
NAME                         READY   STATUS              RESTARTS   AGE
pod/nginx-68c669f78d-wgnp4   0/1     ContainerCreating   0          10s

NAME            TYPE           CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE
service/nginx   LoadBalancer   10.43.197.4   <pending>     80:32754/TCP   10s

NAME                    READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/nginx   0/1     1            0           10s

NAME                               DESIRED   CURRENT   READY   AGE
replicaset.apps/nginx-68c669f78d   1         1         0       10s

# 간단하게 nginx 에 관련된 deployment / service / pod 들이 설치되었다.


# 설치 삭제
$ helm -n user02 delete nginx

$ ku get all
No resources found in user02 namespace.
```











# 2. Redis Cluster Install

kubernetes 기반에서 Redis 를 설치해보자.

참조link : https://github.com/bitnami/charts/tree/master/bitnami/redis-cluster



## 1) namespace 생성

```sh
$ kubectl create ns redis-cluster

```



## 2) helm chart download



### (1) Repo add

redis-cluster chart 를 가지고 있는 bitnami repogistory 를  helm repo 에 추가한다.

```sh
$ helm repo add bitnami https://charts.bitnami.com/bitnami
$ helm repo list
NAME    URL
bitnami https://charts.bitnami.com/bitnami

# helm repo update
$ helm repo update
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the "bitnami" chart repository
Update Complete. ⎈Happy Helming!⎈

```



### (2) Helm Search

추가된 bitnami repo에서 redis-cluster 를 찾는다.

```sh
$ helm search repo redis
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
bitnami/redis           18.0.1          7.2.0           Redis(R) is an open source, advanced key-value ...
bitnami/redis-cluster   9.0.1           7.2.0           Redis(R) is an open source, scalable, distribut...


# 2024.03.03
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
bitnami/redis           18.17.0         7.2.4           Redis(R) is an open source, advanced key-value ...
bitnami/redis-cluster   9.7.0           7.2.4           Redis(R) is an open source, scalable, distribut...


```

우리가 사용할 redis-cluster 버젼은 chart version 9.7.0( app version: 7.2.4) 이다.



### (3) Helm Fetch

helm chart 를 fetch 받는다.

```sh
# chart 를 저장할 적당한 위치로 이동
$ mkdir -p ~/temp/helm/charts
  cd ~/temp/helm/charts

$ helm fetch bitnami/redis-cluster

$ ll
-rw-r--r-- 1 ubuntu ubuntu 92811 Mar  9 06:22 redis-cluster-9.7.0.tgz







$ tar -xzvf redis-cluster-9.7.0.tgz
...

$ cd redis-cluster

$ ls -ltr
-rw-r--r-- 1 ubuntu ubuntu    351 Feb 26 08:53 .helmignore
-rw-r--r-- 1 ubuntu ubuntu    226 Feb 26 08:53 Chart.lock
-rw-r--r-- 1 ubuntu ubuntu   1019 Feb 26 08:53 Chart.yaml
-rw-r--r-- 1 ubuntu ubuntu 112917 Feb 26 08:53 README.md
drwxrwxr-x 3 ubuntu ubuntu   4096 Mar  3 15:43 charts/
drwxrwxr-x 2 ubuntu ubuntu   4096 Mar  3 15:43 templates/
-rw-r--r-- 1 ubuntu ubuntu  50177 Feb 26 08:53 values.yaml



```





## 3) Install

> without pv





### (1) values.yaml 확인

```sh
$ cd  ~/temp/helm/charts/redis-cluster

$ vi values.yaml

# 확인


```







### (2) helm install

```sh
$ cd  ~/temp/helm/charts/redis-cluster

## dry-run 으로 실행
$ helm -n redis-cluster install ds-redis . \
    --set password=new1234 \
    --set persistence.enabled=false \
    --set metrics.enabled=false \
    --set cluster.nodes=6 \
    --set cluster.replicas=1 \
    --dry-run=true


# 실행 될 yaml 확인



#------[참고] 추가옵션---------------
    ### 아래와 같이 설정되면 svc 명으로 redirect 됨
    --set cluster.externalAccess.enabled=true \
    --set cluster.externalAccess.service.type=LoadBalancer \
    --set cluster.externalAccess.service.loadBalancerIP[0]=ds-redis-cluster-0-svc \
    --set cluster.externalAccess.service.loadBalancerIP[1]=ds-redis-cluster-1-svc \
    --set cluster.externalAccess.service.loadBalancerIP[2]=ds-redis-cluster-2-svc \
    --set cluster.externalAccess.service.loadBalancerIP[3]=ds-redis-cluster-3-svc \
    --set cluster.externalAccess.service.loadBalancerIP[4]=ds-redis-cluster-4-svc \
    --set cluster.externalAccess.service.loadBalancerIP[5]=ds-redis-cluster-5-svc \
    

## redis-cluster 설치
$ helm -n redis-cluster install ds-redis . \
    --set password=new1234 \
    --set persistence.enabled=false \
    --set metrics.enabled=false \
    --set cluster.nodes=6 \
    --set cluster.replicas=1 


# [참고]
    # node port 접속시 - redis cluster  에서는 의미 없다.
    --set service.type=NodePort \
    --set service.nodePorts.redis=32300 \

# 
NAME: ds-redis
LAST DEPLOYED: Sat Mar  9 06:28:10 2024
NAMESPACE: redis-cluster
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
CHART NAME: redis-cluster
CHART VERSION: 9.7.0
APP VERSION: 7.2.4** Please be patient while the chart is being deployed **



## 확인
$ helm -n redis-cluster ls
NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                   APP VERSION
ds-redis      redis-cluster    1               2023-09-03 03:53:28.268329606 +0000 UTC deployed        redis-cluster-9.0.1     7.2.0


## 확인
$ helm -n redis-cluster status ds-redis

```



#### Cluster topology

cluster 를 성공적으로 setup 하려면 최소 3개의 master node 를구성해야 한다.

그러므로 전체 node 수는 아래와 같이 구성해야 한다.

```
nodes = numOfMasterNodes + (numOfMasterNodes * replicas)
```

따라서 설치 기본값인 `cluster.nodes=6`, `cluster.replicas=1` 의 의미는 master node 3개 ,  replica node 3개를 뜻한다.



master 가 down 될때 slave 가 master 로 승격된다.  down된 master가 저장한 slots 은 slave 가 승격될때까지 unavailible 상태가 된다.

만약 master 와 그의 slave 가 모두 down 될때는  그중 하나가 정상이 될때까지 cluster 가 down 된다.  

따라서 이러한 downtime 을 줄이기 위해서는 replicas 수를 늘려서 셋팅하는 방법이 있을 수 있다.

예를 다음과 같다.

```
cluster.nodes=9 ( 3 master plus 2 replicas for each master)
cluster.replicas=2
```

위와 같이 설정하게 되면 3 개의 master node와 master 각각 2개의 slave 를 갖게 된다.



#### externalAccess 설정

기본적으로 redis cluster 는 k8s cluster 외부에서 접근하지 못한다.  

Cluster 외부에서 접근하기 위해서는 `cluster.externalAccess.enabled=true` 옵션과 함께 세부 셋팅을 추가해야 한다.

6개의 LoadBalancer services 가 생기며 각각 한개의 node 로 접근가능한 구조로 셋팅된다.







### (3) pod/svc 확인

```sh
## redis cluster 를 구성하고 있는 pod 를 조회
$ kubectl -n redis-cluster get pod -o wide
NAME                       READY   STATUS    RESTARTS   AGE     IP           NODE        NOMINATED NODE   READINESS GATES
ds-redis-redis-cluster-1   1/1     Running   0          6m13s   10.42.2.69   bastion02   <none>           <none>
ds-redis-redis-cluster-3   1/1     Running   0          6m13s   10.42.2.71   bastion02   <none>           <none>
ds-redis-redis-cluster-5   1/1     Running   0          6m13s   10.42.2.72   bastion02   <none>           <none>
ds-redis-redis-cluster-2   1/1     Running   0          6m13s   10.42.2.70   bastion02   <none>           <none>
ds-redis-redis-cluster-4   1/1     Running   0          6m13s   10.42.2.73   bastion02   <none>           <none>
ds-redis-redis-cluster-0   1/1     Running   0          6m13s   10.42.2.68   bastion02   <none>           <none>




$ kubectl -n redis-cluster get svc
NAME                              TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)              AGE
ds-redis-redis-cluster-headless   ClusterIP   None           <none>        6379/TCP,16379/TCP   6m25s
ds-redis-redis-cluster            ClusterIP   10.43.240.69   <none>        6379/TCP             6m25s



```

kubernetes Cluster 내부에서는 ds-redis-redis-cluster:6379 라는 서비스명으로 접근할 것이다.

특정 pod 로 직접 접근할때는 POD 의 IP 를 직접 사용하거나 아래와 같이 headless service 를 이용하는 방법도 있으니 참고하자.

* ds-redis-redis-cluster-0.ds-redis-redis-cluster-headless.redis-cluster.svc
* ds-redis-redis-cluster-1.ds-redis-redis-cluster-headless.redis-cluster.svc
* ds-redis-redis-cluster-2.ds-redis-redis-cluster-headless.redis-cluster.svc
* ds-redis-redis-cluster-3.ds-redis-redis-cluster-headless.redis-cluster.svc
* ds-redis-redis-cluster-4.ds-redis-redis-cluster-headless.redis-cluster.svc
* ds-redis-redis-cluster-5.ds-redis-redis-cluster-headless.redis-cluster.svc







## 3) Internal Access

redis client를 cluster 내부에서 실행 후 접근하는 방법을 알아보자.

### (1) Redis client 실행

먼저 아래와 같이 동일한 Namespace 에 redis-client 를 실행한다.

```sh
## redis-client 용도로 deployment 를 실행한다.
$ kubectl -n redis-cluster create deploy redis-client --image=docker.io/redis:7.2 -- sleep 365d
deployment.apps/redis-client created


## redis client pod 확인
$ kubectl -n redis-cluster get pod
NAME                           READY   STATUS    RESTARTS   AGE
redis-client-9f57dc6d6-7kffv   1/1     Running   0          7s


# 약 20초 정도 소요됨


## redis-client pod 내부로 접근한다.
$ kubectl -n redis-cluster exec -it deploy/redis-client -- bash
root@redis-client-9f57dc6d6-7kffv:/data#                    # <-- 이런 Prompt가 나오면 정상


```



### (2) Redis-cli 으로 확인

#### Redis-cli 실행

```sh
## redis-client pod 내부에서...


## service 명으로 cluster mode 접근
$ redis-cli -h ds-redis-redis-cluster -c -a new1234

# 특정 pod 로 직접 접근 시도시
# redis-cli -h ds-redis-redis-cluster-0.ds-redis-redis-cluster-headless.redis-cluster.svc -c -a new1234
# redis-cli -h ds-redis-redis-cluster-1.ds-redis-redis-cluster-headless.redis-cluster.svc -c -a new1234
# redis-cli -h ds-redis-redis-cluster-2.ds-redis-redis-cluster-headless.redis-cluster.svc -c -a new1234
# redis-cli -h ds-redis-redis-cluster-3.ds-redis-redis-cluster-headless.redis-cluster.svc -c -a new1234
# redis-cli -h ds-redis-redis-cluster-4.ds-redis-redis-cluster-headless.redis-cluster.svc -c -a new1234
# redis-cli -h ds-redis-redis-cluster-5.ds-redis-redis-cluster-headless.redis-cluster.svc -c -a new1234





## cluster node 를 확인
$ ds-redis-redis-cluster:6379> cluster nodes
d3d0831adef812640c1cbc638863d65563746b7d 10.42.2.72:6379@16379 slave 761736a05e1d63c699cdd8cc14b8773f6c025086 0 1709966406610 2 connected
0f1b5b465fa911d3b74b6b9de5f64c4dfcdace85 10.42.2.71:6379@16379 myself,slave 9110f576743a5799771ae9098e6366698ef94cf5 0 1709966404000 3 connected
761736a05e1d63c699cdd8cc14b8773f6c025086 10.42.2.69:6379@16379 master - 0 1709966405608 2 connected 5461-10922
b7db18fba19071ee431141abae6d0ba86fe31735 10.42.2.68:6379@16379 master - 0 1709966403000 1 connected 0-5460
9110f576743a5799771ae9098e6366698ef94cf5 10.42.2.70:6379@16379 master - 0 1709966405000 3 connected 10923-16383
6fdb1e6ab1366cc61dc806dae56df4212d1459d5 10.42.2.73:6379@16379 slave b7db18fba19071ee431141abae6d0ba86fe31735 0 1709966406000 1 connected

## master 3개, slave가 3개 사용하는 모습을 볼 수가 있다.



## cluster info 확인
ds-redis-redis-cluster:6379> cluster info

cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:6
cluster_my_epoch:1
cluster_stats_messages_ping_sent:236
cluster_stats_messages_pong_sent:233
cluster_stats_messages_sent:469
cluster_stats_messages_ping_received:228
cluster_stats_messages_pong_received:236
cluster_stats_messages_meet_received:5
cluster_stats_messages_received:469
total_cluster_links_buffer_limit_exceeded:0

## cluster state 가 OK 인 것을 확인할 수 있다.

```



#### set / get 확인

```sh

# Redis cli 에서...


## set 명령 수행
ds-redis-redis-cluster:6379> set a 1
-> Redirected to slot [15495] located at 10.42.0.28:6379
OK
10.42.0.28:6379> set b 2
-> Redirected to slot [3300] located at 10.42.0.27:6379
OK
10.42.0.27:6379> set c 3
-> Redirected to slot [7365] located at 10.42.0.26:6379
OK
10.42.0.26:6379> set d 4
-> Redirected to slot [11298] located at 10.42.0.28:6379
OK
10.42.0.28:6379> set e 5
OK
10.42.0.28:6379> set f 6
-> Redirected to slot [3168] located at 10.42.0.27:6379
OK

## Set 명령수행시 master node 를 변경하면서 set 하는 모습을 확인할 수 있다.



# get 명령 수행
10.42.0.27:6379> get a
-> Redirected to slot [15495] located at 10.42.0.28:6379
"1"
10.42.0.28:6379> get b
-> Redirected to slot [3300] located at 10.42.0.27:6379
"2"
10.42.0.27:6379> get c
-> Redirected to slot [7365] located at 10.42.0.26:6379
"3"
10.42.0.26:6379> get d
-> Redirected to slot [11298] located at 10.42.0.28:6379
"4"
10.42.0.28:6379> get e
"5"
10.42.0.28:6379> get f
-> Redirected to slot [3168] located at 10.42.0.27:6379
"6"


## get 명령을 실행하면 해당 데이터가 존재하는 master pod 로 redirectred 되는 것을 확인할 수 있다.


# 테스트 완료후 
# Ctrl+C ,  Ctrl+D 명령으로 Exit 하자.

```



### (3) python 으로 확인

Kubernetes Cluster 내에서 redis 접근 가능여부를 확인하기 위해 python 을 설치후 redis 에 connect 해 보자.



#### python  설치

```sh
# python deploy
$ kubectl -n redis-cluster create deploy python --image=python:3.9 -- sleep 365d


# 설치진행 확인
$ kubectl -n redis-cluster get pod
...
python-fb57f7bd4-4w6pz                       1/1     Running   0              32s
...

## READY 상태가 1/1 로 변할때까지 대기...
## 약 1분 소요


# python pod 내부로 진입( bash 명령 수행)
$ kubectl -n redis-cluster exec -it deploy/python -- bash
root@python-7d59455985-ml8vw:/#                  <-- 이런 prompt 가 정상


```



#### python library install

kafka 에 접근하기 위해서 kafka-python 을 설치해야 한다.

```bash
# python pod 내부에서

$ pip install redis-py-cluster

Collecting redis-py-cluster
  Downloading redis_py_cluster-2.1.3-py2.py3-none-any.whl (42 kB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 42.6/42.6 kB 2.8 MB/s eta 0:00:00
Collecting redis<4.0.0,>=3.0.0
  Downloading redis-3.5.3-py2.py3-none-any.whl (72 kB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 72.1/72.1 kB 6.9 MB/s eta 0:00:00
Installing collected packages: redis, redis-py-cluster
Successfully installed redis-3.5.3 redis-py-cluster-2.1.3


```



#### [참고] redis host 확인

```sh
# internal 접근을 위한 host 확인
# nc 명령으로 접근가능여부를 확인할 수 있다.

$ apt update
  apt install netcat-openbsd

$ nc -zv ds-redis-redis-cluster.redis-cluster.svc 6379

Connection to ds-redis-redis-cluster.redis-cluster.svc (10.43.47.183) 6379 port [tcp/redis] succeeded!

# [참고] externalAccess 방식으로 설치했을 경우
$ nc -zv ds-redis-redis-cluster-0-svc.redis-cluster.svc 6379
$ nc -zv ds-redis-redis-cluster-1-svc.redis-cluster.svc 6379
$ nc -zv ds-redis-redis-cluster-2-svc.redis-cluster.svc 6379
$ nc -zv ds-redis-redis-cluster-3-svc.redis-cluster.svc 6379
$ nc -zv ds-redis-redis-cluster-4-svc.redis-cluster.svc 6379
$ nc -zv ds-redis-redis-cluster-5-svc.redis-cluster.svc 6379


```



#### Redis 확인

consumer 실행을 위해서 python cli 환경으로 들어가자.

```sh
# python pod 내부에서

$ python

Python 3.9.18 (main, Feb 13 2024, 10:54:04)
[GCC 12.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>>



```



CLI 환경에서 아래  Python 명령을 하나씩 실행해 보자.

```python
from rediscluster import RedisCluster

startup_nodes = [{"host":"ds-redis-redis-cluster", "port":"6379"}]
rc = RedisCluster(startup_nodes=startup_nodes, 
                  decode_responses=True, 
                  skip_full_coverage_check=True,
                  password="new1234")

print(rc.cluster('slots'))

'''
{
(0, 5460): {'master': ('10.42.0.172', 6379), 'slaves': [('10.42.0.175', 6379)]},
(5461, 10922): {'master': ('10.42.0.170', 6379), 'slaves': [('10.42.0.174', 6379)]},
(10923, 16383): {'master': ('10.42.0.168', 6379), 'slaves': [('10.42.0.173', 6379)]}
}
'''

'''
externalAccess 일 경우
{
(0, 5460): {'master': ('ds-redis-redis-cluster-0-svc', 6379), 'slaves': [('ds-redis-redis-cluster-4-svc', 6379)]}, 
(5461, 10922): {'master': ('ds-redis-redis-cluster-1-svc', 6379), 'slaves': [('ds-redis-redis-cluster-5-svc', 6379)]}, 
(10923, 16383): {'master': ('ds-redis-redis-cluster-2-svc', 6379), 'slaves': [('ds-redis-redis-cluster-3-svc', 6379)]}
}
'''



# redis set
rc.set("a", 1)
rc.set("b", 2)
rc.set("c", 3)

# redis get
rc.get("a")
rc.get("b")
rc.get("c")


# redis set
rc.set("d", "python4")

# delete key
rc.delete("d")


# 기타
key_list  = rc.keys("*")
print(key_list)


# 10000건을 1초에 한번씩 읽어 보자.
from time import sleep
for i in range(10000):
    print(i)
    sleep(1)
    rc.get("a")
    rc.get("b")
    rc.get("c")



# 테스트를 끝내려면 Ctrl + C 로 중지하자.

```





### (4) 성능테스트(Python)

#### 소스 받기

```sh
# python pod 내부에서

# 소스 받기

# 처음이라면 git clone
$ mkdir ~/githubrepo
  cd ~/githubrepo

$ git clone https://github.com/ssongman/ktds-edu-redis.git


# 이미 받았다면 git pull
$ cd ~/githubrepo/ktds-edu-redis
  git pull


```



#### 1만건 쓰기 테스트

```sh
# python pod 내부에서

# 소스 확인
$ cat ~/githubrepo/ktds-edu-redis/redis/PythonSample/11.spt-cluster-set.py


# 실행
$ cd ~/githubrepo/ktds-edu-redis/redis/PythonSample
  python 11.spt-cluster-set.py

[key 1] duration time : 2.5676867961883545
[key 2] duration time : 5.0153820514678955
[key 3] duration time : 7.606504201889038

```

* 약 2초 정도 소요됨
* 3개의 키를 쓸때는 약 3배수 정도 소요됨





#### 1만건 읽기 테스트

```sh
# python pod 내부에서

# 소스 확인
$ cat ~/githubrepo/ktds-edu-redis/redis/PythonSample/12.spt-cluster-get.py


# 실행
$ cd ~/githubrepo/ktds-edu-redis/redis/PythonSample
  python 12.spt-cluster-get.py

[key 1] duration time : 1.9574801921844482
[key 2] duration time : 3.4621880054473877
[key 3] duration time : 5.961182117462158



```

* 약 2초 정도 소요됨
* 3개의 키를 읽어올때는 3배수 정도 소요됨







## 4) External Access

Redis Cluster 는 K8s 내부에서만 사용가능한 주소체계로 redirect 되므로 k8s 외부에서는 접근이 불가능하다.



### External Access 의 한계

- redirect가 정확히 이루어지려면 Client 가 인식가능한 Node 주소를 알아야 함

- 하지만 Redis Cluster 는 원격지 Client 가 인식가능한 Node 들의 DNS 제공을 지원하지 않음

- 결국 Redis Cluster 는 PRD환경과 같이 Kubernetes Cluster 내에서는 사용가능하지만 

- 개발자 PC에서 연결이 필요한 DEV환경에서 적절치 않음



### External Access 를 가능하게 하려면...

* 아래와 같이 상황별 세부 설정작업이 필요하다.
  * 멀티 클러스터간 통신 설정
    *  istio 의 MultiCluster 기능 이용
    * Cilium CNI 등을 이용하여 멀티 클러스터 간 통신 설정
  * 클러스터 외부 접근이 필요하다면
    * 6개 Worker node 를 준비하여 Host Port 로 POD 를 구동
    * 외부에서 접근시 Worker node IP 로 직접 연결





## 5) [참고] Clean Up

```sh

# 1) helm 삭제
# helm delete 명령을 이용하면 helm chart 로 설치된 모든 리소스가 한꺼번에 삭제된다.
$ helm -n redis-cluster delete ds-redis
$ helm -n redis-cluster ls


# 2) helm chart 삭제
$ rm -rf ~/temp/helm/charts/redis-cluster/


## 3) redis-client 삭제
#$ kubectl -n redis-cluster delete deploy/redis-client
#$ kubectl -n redis-cluster delete deploy/python

# 확인
$ kubectl -n redis-cluster get all


```







# 3. Redis Install

Redis-Cluster 는 Local 에서 접속 시도할때는 Redirect 가 불가능하므로 사용할 수 없다.

그러므로 redis-cluster 가 아닌 redis 로 설치 하여 테스트를 진행한다.



## 1) namespace 생성

```sh
$ kubectl create ns redis-mr

```



## 2) Redis(Master Replica) Install



### (1) helm search

추가된 bitnami repo에서 redis-cluster 를 찾는다.

```sh
$ helm search repo redis
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
bitnami/redis           18.0.1          7.2.0           Redis(R) is an open source, advanced key-value ...
bitnami/redis-cluster   9.0.1           7.2.0           Redis(R) is an open source, scalable, distribut...

# 2024.03.08
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
bitnami/redis           18.17.1         7.2.4           Redis(R) is an open source, advanced key-value ...
bitnami/redis-cluster   9.7.0           7.2.4           Redis(R) is an open source, scalable, distribut...



```

bitnami/redis chart (18.17.1 ) 를 이용할 것이다.



### (2) helm install

```sh

# helm install
# master 1, slave 2 실행

# dry-run
$ helm -n redis-mr install ds-redis bitnami/redis \
    --set global.redis.password=new1234 \
    --set image.registry=docker.io \
    --set master.persistence.enabled=false \
    --set master.service.type=NodePort \
    --set master.service.nodePorts.redis=32300 \
    --set replica.replicaCount=2 \
    --set replica.persistence.enabled=false \
    --set replica.service.type=NodePort \
    --set replica.service.nodePorts.redis=32310 \
    --dry-run=true


# 실제 설치
$ helm -n redis-mr install ds-redis bitnami/redis \
    --set global.redis.password=new1234 \
    --set image.registry=docker.io \
    --set master.persistence.enabled=false \
    --set master.service.type=NodePort \
    --set master.service.nodePorts.redis=32300 \
    --set replica.replicaCount=2 \
    --set replica.persistence.enabled=false \
    --set replica.service.type=NodePort \
    --set replica.service.nodePorts.redis=32310

##
NAME: ds-redis
LAST DEPLOYED: Fri Mar  8 12:36:21 2024
NAMESPACE: redis-mr
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
CHART NAME: redis
CHART VERSION: 18.17.1
APP VERSION: 7.2.4
...


# 확인
$ helm -n redis-mr ls
NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART           APP VERSION
ds-redis        redis-mr        1               2024-03-08 12:36:21.666880881 +0000 UTC deployed        redis-18.17.1   7.2.4



# 확인
$ helm -n redis-mr status ds-redis
$ helm -n redis-mr get all ds-redis


```





#### [참고] remote설치가 안될때는 fetch 받아서 수행

설치 과정에서 chart 를 다운 받지 못한다면 Chart 를 fetch 받아서 설치하자.

```sh
# chart 를 저장할 적당한 위치로 이동
$ mkdir -p ~/helm/charts

$ cd ~/helm/charts

$ helm fetch bitnami/redis

$ ll
-rw-r--r-- 1 song song 88772 Jul  3 16:46 redis-16.13.1.tgz

$ tar -xzvf redis-16.13.1.tgz
...

$ cd redis

$ ls -ltr
-rw-r--r-- 1 song song    333 Jun 30 18:13 .helmignore
-rw-r--r-- 1 song song    220 Jun 30 18:13 Chart.lock
-rw-r--r-- 1 song song    773 Jun 30 18:13 Chart.yaml
-rw-r--r-- 1 song song 100896 Jun 30 18:13 README.md
drwxr-xr-x 3 song song   4096 Jul  3 16:46 charts/
drwxr-xr-x 2 song song   4096 Jul  3 16:46 img/
drwxr-xr-x 5 song song   4096 Jul  3 16:46 templates/
-rw-r--r-- 1 song song   4483 Jun 30 18:13 values.schema.json
-rw-r--r-- 1 song song  68559 Jun 30 18:13 values.yaml



$ cd ~/helm/charts/redis

# helm install
$ helm -n redis-mr install ds-redis . \
    --set global.redis.password=new1234 \
    --set image.registry=docker.io \
    --set master.persistence.enabled=false \
    --set master.service.type=NodePort \
    --set master.service.nodePorts.redis=32300 \
    --set replica.replicaCount=2 \
    --set replica.persistence.enabled=false \
    --set replica.service.type=NodePort \
    --set replica.service.nodePorts.redis=32310

##
ds-redis-master .redis-mr.svc.cluster.local for read/write operations (port 6379)
ds-redis-replicas.redis-mr.svc.cluster.local for read-only operations (port 6379)

```





### (3) pod / svc 확인

```sh

$ kubectl -n redis-mr get svc
NAME                TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE
ds-redis-headless   ClusterIP   None           <none>        6379/TCP         2m47s
ds-redis-replicas   NodePort    10.43.63.201   <none>        6379:32310/TCP   2m47s
ds-redis-master    NodePort    10.43.67.216   <none>        6379:32300/TCP   2m47s



$ kubectl -n redis-mr get pod
NAME                  READY   STATUS    RESTARTS   AGE
ds-redis-master-0     1/1     Running   0          2m12s
ds-redis-replicas-0   1/1     Running   0          2m12s
ds-redis-replicas-1   1/1     Running   0          106s


# 약 1분 정도 소요됨 

```

- Redis Cluster 와는 다르게 Redis Master Replica 구조에서는 각각의 node를  Read/Write 용도로 구분해서 사용할 수 있다.
  - ds-redis-master는 read/write 용도로 사용되며 ds-redis-replicas 는 read-only 용도로 사용되기도 한다.

- kubernetes Cluster 내부에서는 ServiceName:6379 라는 서비스명으로 접근할 것이다.
  -  ds-redis-master:6379 

- 외부에서 접근시에는 nodeport 로 접근 한다.
  - Node_IP:32310






## 3) Internal Access

redis client를 cluster 내부에서 실행후 접근하는 방법을 알아보자.



### (1) Redis Service 확인

```sh
$ kubectl -n redis-mr get pod
NAME                  READY   STATUS    RESTARTS   AGE
ds-redis-master-0     1/1     Running   0          2m12s
ds-redis-replicas-0   1/1     Running   0          2m12s
ds-redis-replicas-1   1/1     Running   0          106s


$ kubectl -n redis-mr get svc
NAME                TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE
ds-redis-headless   ClusterIP   None           <none>        6379/TCP         2m47s
ds-redis-replicas   NodePort    10.43.63.201   <none>        6379:32310/TCP   2m47s
ds-redis-master    NodePort    10.43.67.216   <none>        6379:32300/TCP   2m47s

```

- 일반 service
  - ds-redis-master/ ds-redis-replicas
  - 일반 kubernetes service 이며 POD 로 트래픽을 RR 방식으로 연결한다.
  - service 사용예시
    - ds-redis-master:6379
    - ds-redis-replicas:6379

- headless service
  - ds-redis-redis-headless 는 ip 가 없는 headless service 이다. 그러므로 pod 명을 붙여서 DNS 로 사용된다.
  - headless service 사용예시
    - ds-redis-master-0.ds-redis-headless.redis-mr.svc.cluster.local:6379
    - ds-redis-replicas-0.ds-redis-headless.redis-mr.svc.cluster.local:6379
    - ds-redis-replicas-1.ds-redis-headless.redis-mr.svc.cluster.local:6379
    - ds-redis-replicas-2.ds-redis-headless.redis-mr.svc.cluster.local:6379


우리는 Cluster 내에서  ds-redis-master:6379로 접근을 시도할 것이다.





### (2) Redis-cli 으로 확인

#### Redis-cli 실행

먼저 아래와 같이 동일한 Namespace 에 redis-client 를 실행한다.

```sh
## redis-client 용도로 deployment 를 실행한다.
$ kubectl -n redis-mr create deploy redis-client --image=docker.io/redis:7.2 -- sleep 365d
deployment.apps/redis-client created


## redis client pod 확인
$ kubectl -n redis-mr get pod
NAME                           READY   STATUS    RESTARTS   AGE
redis-client-9f57dc6d6-j578s   1/1     Running   0          14s
...


# 약 10초 정도 소요된다.


## redis-client 로 접근한다.
$ kubectl -n redis-mr exec -it deploy/redis-client -- bash

root@redis-client-9f57dc6d6-j578s:/data#                         # <-- 이런 Prompt 가 나오면 정상


```





#### Master set/get 확인

```sh
## redis-client pod 내부에서...

# master connect
$ redis-cli -h ds-redis-master -a new1234



## set 명령 수행
ds-redis-master:6379> set a 1
OK
ds-redis-master:6379> set b 2
OK
ds-redis-master:6379> set c 3
OK


# get 명령 수행
ds-redis-master:6379> get a
"1"
ds-redis-master:6379> get b
"2"
ds-redis-master:6379> get c
"3"


## Redis Cluster 와 다르게 한개의 노드에서만 동작한다.


# 테스트 완료시
# Ctrl+D,   Ctrl+D 로   Exit 하자.
```



#### Replicas set/get 확인

```sh
## redis-client pod 내부에서...

# replicas connect
$ redis-cli -h ds-redis-replicas -a new1234

ds-redis-replicas:6379>


# get 명령 수행
ds-redis-replicas:6379> get a
"1"
ds-redis-replicas:6379> get b
"2"
ds-redis-replicas:6379> get c
"3"


## set 명령 수행
ds-redis-replicas:6379> set a 11
(error) READONLY You can't write against a read only replica.

# replicas 는 readonly 이다.

# 테스트 완료시
# Ctrl+D,   Ctrl+D 로   Exit 하자.
```





### (3) python 으로 확인

Kubernetes Cluster 내에서 redis 접근 가능여부를 확인하기 위해 python 을 설치후 redis 에 connect 해 보자.



#### python  설치

```sh
# python deploy
$ kubectl -n redis-mr create deploy python --image=python:3.9 -- sleep 365d


# 설치진행 확인
$ kubectl -n redis-mr get pod
NAME                           READY   STATUS    RESTARTS   AGE
python-5847f48f6c-hqcgj        1/1     Running   0          24s
...



## READY 상태가 1/1 로 변할때까지 대기...
## 약 1분 소요


# python pod 내부로 진입( bash 명령 수행)
$ kubectl -n redis-mr exec -it deploy/python -- bash
root@python-7d59455985-ml8vw:/#                  <-- 이런 prompt 가 정상


```



#### python library install

kafka 에 접근하기 위해서 kafka-python 을 설치해야 한다.

```bash
# python pod 내부에서

$ pip install redis

Collecting redis
  Downloading redis-5.0.0-py3-none-any.whl (250 kB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 250.1/250.1 kB 6.6 MB/s eta 0:00:00
Collecting async-timeout>=4.0.2
  Downloading async_timeout-4.0.3-py3-none-any.whl (5.7 kB)
Installing collected packages: async-timeout, redis
Successfully installed async-timeout-4.0.3 redis-5.0.0


```



#### [참고] redis host 확인

```sh
# internal 접근을 위한 host 확인
# nc 명령으로 접근가능여부를 확인할 수 있다.

$ apt update
  apt install netcat-openbsd

$ nc -zv ds-redis-master.redis-mr.svc 6379

Connection to ds-redis-master.redis-mr.svc (10.43.67.216) 6379 port [tcp/redis] succeeded!

```



#### Redis 확인

consumer 실행을 위해서 python cli 환경으로 들어가자.

```sh
# python pod 내부에서
$ python

Python 3.9.18 (main, Feb 13 2024, 10:54:04)
[GCC 12.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.




```



CLI 환경에서 아래  Python 명령을 하나씩 실행해 보자.

```python
# python Prompt 에서

import redis

# redis 연결
rd = redis.Redis(host='ds-redis-master', port=6379, db=0, password="new1234")


'''
# [참고] sample connection
rd = redis.StrictRedis(host='ds-redis-master', port=6379, db=0, password="new1234")
rd = redis.Redis(host='localhost', port=6379, decode_responses=True)
rc = RedisCluster(host='ds-redis-redis-mr', port=6379)

rd = redis.Redis(
    host="my-redis.cloud.redislabs.com", port=6379,
    username="default", # use your Redis user. More info https://redis.io/docs/management/security/acl/
    password="secret", # use your Redis password
    ssl=True,
    ssl_certfile="./redis_user.crt",
    ssl_keyfile="./redis_user_private.key",
    ssl_ca_certs="./redis_ca.pem",
)
'''


# redis get
rd.get("a")
rd.get("b")
rd.get("c")


# redis set
rd.set("d", "python4")

# redis get
rd.get("d")


# delete key
rd.delete("d")

# CTRL + D
# CTRL + D  로 터미널을 빠져나온다.
```





### (4) 성능테스트(Python )

#### 소스 받기

```sh
# python pod 내부에서

# 소스 받기

# 처음이라면 git clone
$ mkdir ~/githubrepo
  cd ~/githubrepo

$ git clone https://github.com/ssongman/ktds-edu-redis.git


# 이미 받았다면 git pull
$ cd ~/githubrepo/ktds-edu-redis
  git pull


```



#### 1만건 쓰기 테스트

```sh
# python pod 내부에서

# 소스 확인
$ cat ~/githubrepo/ktds-edu-redis/redis/PythonSample/15.spt-redis-mr-set.py


# 실행
$ cd ~/githubrepo/ktds-edu-redis/redis/PythonSample
  python 15.spt-redis-mr-set.py ds-redis-master.redis-mr.svc 6379


[key 1] duration time : 2.8686742782592773
[key 2] duration time : 5.967571020126343
[key 3] duration time : 9.28812551498413



```

* 약 3초 정도 소요됨
* 3개의 키를 쓸때는 약 3배수 정도 소요됨
* 마지막 3개의 키에서 c는 TTL 까지 셋팅하여 시간이 좀더 많이 소요됨.





#### 1만건 읽기 테스트

```sh
# python pod 내부에서

# 소스 확인
$ cat ~/githubrepo/ktds-edu-redis/redis/PythonSample/16.spt-redis-mr-get.py


# 실행
$ cd ~/githubrepo/ktds-edu-redis/redis/PythonSample
  python 16.spt-redis-mr-get.py ds-redis-master.redis-mr.svc 6379


[key 1] duration time : 2.04624080657959
[key 2] duration time : 3.7809975147247314
[key 3] duration time : 5.390881776809692


```

* 약 2초 정도 소요됨
* 3개의 키를 읽어올때는 3배수 정도 소요됨







## 4) External Access

redis client를 cluster 외부에서 실행후 접근하는 방법을 알아보자.



### (1) Redis Service 확인

```sh
# bastion server 에서...

$ kubectl -n redis-mr get svc

NAME                TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE
ds-redis-headless   ClusterIP   None           <none>        6379/TCP         14m
ds-redis-replicas   NodePort    10.43.63.201   <none>        6379:32310/TCP   14m
ds-redis-master     NodePort    10.43.67.216   <none>        6379:32300/TCP   14m


```

- ds-redis-master 서비스가 Node Port 32300 로 접근이 가능하다.
- 그러므로 Node Ip알아낸 다음 해당 IP 의 33200 로 접근할 수 있다.



### (2) Node IP 확인



#### Node IP 확인

- node port 를 인식할 수 있는 본인 Bastion Server IP를 확인해야 한다.

- Bastion Server IP 는 개인별로 부여된 IP 이므로 이를 사용하자.

  ※ Typora 를 사용하고 있다면 본문서에 등장하는 43.201.82.244 를 모두 자신의 IP 로 Replace 사용하자.

```
Ctrl + H

43.201.82.244 -->  (자신의 Bastion Server IP)   모두 변경
```

- 접근 주소
  - 43.201.82.244:32300
  - 위 주소로 본인의 local PC 에서도 위 Redis 주소로 접근할 수 있다.

  



### (3) Redis client 확인(Docker)

bastion Server 에서 Kubernetes redis access 테스트를 위해 Container redis client 를 설치하자.

```sh
## docker 확인
$ docker ps -a


## redis-client 용도로 docker client 를 실행한다.
$ docker run --name redis-client -d --user root docker.io/redis:7.2 sleep 365d

## docker 내에 진입후
$ docker exec -it redis-client bash


## Local PC IP로 cluster mode 접근
$ redis-cli -h 43.201.82.244 -c -a new1234 -p 32300

```



### (4) set/get 확인

```sh

# get 명령 수행
# Internal Access 에서 테스트 했던 4개 값을 읽어오자.
43.201.82.244:32300> get a
"1"
43.201.82.244:32300> get b
"2"
43.201.82.244:32300> get c
"3"


# set 명령 수행
43.201.82.244:32300> set e 1
OK
43.201.82.244:32300> set f 2
OK
43.201.82.244:32300> set g 3
OK


# 테스트 완료시
# Ctrl+D,   Ctrl+D 로   Exit 하자.
```







## 5) [참고] Clean Up

```sh
# Bastion Server 에서...

# 1) Redis 삭제
$ helm -n redis-mr delete ds-redis
# 확인
$ helm -n redis-mr ls


# 2) redis-client 삭제
$ kubectl -n redis-mr delete deploy/redis-client
# 확인
$ kubectl -n redis-mr get deploy

# 3) python 삭제
$ kubectl -n redis-mr delete deploy/python
# 확인
$ kubectl -n redis-mr get deploy



# 4) namespace 삭제
$ kubectl delete namespace redis-mr


# 5) Container 삭제
$ docker rm -f redis-client
$ docker ps -a

```









# 4. Redis Metrics



## 1) Redis-cli 으로 확인

#### Redis-cli 실행

먼저 아래와 같이 동일한 Namespace 에 redis-client 를 실행한다.

```sh
## redis-client 용도로 deployment 를 실행한다.
$ kubectl -n redis-mr create deploy redis-client --image=docker.io/redis:7.2 -- sleep 365d
deployment.apps/redis-client created

## redis client pod 확인
$ kubectl -n redis-mr get pod
NAME                            READY   STATUS    RESTARTS   AGE
redis-client-69dcc9c76d-rgtgx   1/1     Running   0          8s

# 약 10초 정도 소요된다.


## redis-client 로 접근한다.
$ kubectl -n redis-mr exec -it deploy/redis-client -- bash
root@redis-client-9f57dc6d6-j578s:/data#                            # <-- 이런 Prompt 가 나오면 정상


```





## 2) Redis Info

### redis-client pod 내부

```sh
## redis-client pod 내부에서...

# redis login
$ redis-cli -h ds-redis-master -a new1234



# redis info 
$ ds-redis-master:6379> info
# Server
redis_version:7.2.0
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:2134749ca3475304
redis_mode:standalone
os:Linux 5.19.0-1025-gcp x86_64
arch_bits:64
monotonic_clock:POSIX clock_gettime
multiplexing_api:epoll
atomicvar_api:c11-builtin
gcc_version:10.2.1
process_id:1
process_supervised:no
run_id:2df8ed0436407ea383f12ab89973e32d8d71c388
tcp_port:6379
server_time_usec:1693715749028739
uptime_in_seconds:328
uptime_in_days:0
hz:10
configured_hz:10
lru_clock:15994148
executable:/redis-server
config_file:
io_threads_active:0
listener0:name=tcp,bind=*,bind=-::*,port=6379
...


# redis info all
$ ds-redis-master:6379> info all


```



### info Memory

```sh
$ info memory
# Memory
used_memory:2253616
used_memory_human:2.15M
used_memory_rss:12017664
used_memory_rss_human:11.46M
used_memory_peak:2473888
used_memory_peak_human:2.36M
used_memory_peak_perc:91.10%
...
maxmemory:0
maxmemory_human:0B
maxmemory_policy:noeviction
...
mem_fragmentation_ratio:5.38
mem_fragmentation_bytes:9784720
...

```

* used_memory
  * 현재 Redis 가 계산하고 있는 사용 메모리
* used_memory_rss
  * 데이터를 포함한 실제 redis 가 사용하고 있는 메모리
  * OS가 메모리 할당시 page사이즈의 배수로 할당하기 때문에 Fragmentation현상 발생
  * 그러므로 used_memory 보다 더 크게 할당됨.
  * 실제 물리 메모리보다 더 많은 메모리를 사용하면 Swap 이 발생하며 성능저하로 이어짐
* used_memory_peak
  * 데이터 사용 peak 메모리
* mem_fragmentation_ratio
  * used_memory와 used_memory_rss의 비율
  * 비율이 높으면 fragmentation이 높다고 해석
  * 1보다 작으면 swap 이 발생하고 있음으로 해석

* maxmemory_policy
  * noeviction(기본값)
  * memory가 max 일때 조치하는 정책








### info Stats

```sh
$ info stats

# Stats
total_connections_received:81432
total_commands_processed:598017
instantaneous_ops_per_sec:4
total_net_input_bytes:18534914
total_net_output_bytes:11803204
total_net_repl_input_bytes:0
total_net_repl_output_bytes:7629802
instantaneous_input_kbps:0.20
instantaneous_output_kbps:0.01
instantaneous_input_repl_kbps:0.00
instantaneous_output_repl_kbps:0.00
rejected_connections:0
sync_full:2
sync_partial_ok:0
sync_partial_err:1
expired_keys:0
expired_stale_perc:0.00
expired_time_cap_reached_count:0
expire_cycle_cpu_milliseconds:1521
evicted_keys:0
evicted_clients:0
total_eviction_exceeded_time:0
current_eviction_exceeded_time:0
keyspace_hits:150010
keyspace_misses:30004
pubsub_channels:0
pubsub_patterns:0
pubsubshard_channels:0
latest_fork_usec:386
total_forks:2
migrate_cached_sockets:0
slave_expires_tracked_keys:0
active_defrag_hits:0
active_defrag_misses:0
active_defrag_key_hits:0
active_defrag_key_misses:0
total_active_defrag_time:0
current_active_defrag_time:0
tracking_total_keys:0
tracking_total_items:0
tracking_total_prefixes:0
unexpected_error_replies:0
total_error_replies:3
dump_payload_sanitizations:0
total_reads_processed:679447
total_writes_processed:716420
io_threaded_reads_processed:0
io_threaded_writes_processed:0
reply_buffer_shrinks:20
reply_buffer_expands:6
eventloop_cycles:1413094
eventloop_duration_sum:142518201
eventloop_duration_cmd_sum:1571365
instantaneous_eventloop_cycles_per_sec:15
instantaneous_eventloop_duration_usec:112
acl_access_denied_auth:0
acl_access_denied_cmd:0
acl_access_denied_key:0
acl_access_denied_channel:0

```

* total_commands_processed
  * 지금까지 처리한 명령수
* instantaneous_ops_per_sec
  * 초당 실행 명령 수, Redis 는 CPU의 영향을 받으므로 더 성능이 좋은 CPU 를 사용하면 처리량이 늘어난다.
* expired_keys
  * 지금까지 expireation 발생한 이벤트 수
* keyspace_hits
  * 캐시 Hit 수
* keyspace_misses
  * 캐시 Miss 수





### info Clients

```sh
$ info Clients

# Clients
connected_clients:2
cluster_connections:0
maxclients:10000
client_recent_max_input_buffer:20480
client_recent_max_output_buffer:20504
blocked_clients:0
tracking_clients:0
clients_in_timeout_table:0
total_blocking_keys:0
total_blocking_keys_on_nokey:0

```

* connected_clients
  * 현재 접속해 있는 클라이언트 수
  * Redis 는 싱글 스레드 기반이라 클라이언트가 지속적으로 연결/연결해제를 할 경우 성능이 떨어지므로 해당 값이 크게 계속 변경되면 성능 저하됨
    * ex) 단일 명령처리 단위로 Connection 을 맺는 대량의 배치 경우임
    * 이런 경우 한번의 Connection 으로 배치처리를 완료하는 방식으로 변경 필요
* maxclients
  * 접속할 수 있는 최대 클라이언트의 수
  * 충분하지 않으면 모니터링 tool 들이 connection 하지 못하는 상황이 있을 수 있음





### info Replication

```sh
$ info replication
# Replication
role:master
connected_slaves:3
slave0:ip=ds-redis-replicas-0.ds-redis-redis-headless.redis-mr.svc.cluster.local,port=6379,state=online,offset=36518,lag=0
slave1:ip=ds-redis-replicas-1.ds-redis-redis-headless.redis-mr.svc.cluster.local,port=6379,state=online,offset=36518,lag=0
slave2:ip=ds-redis-replicas-2.ds-redis-redis-headless.redis-mr.svc.cluster.local,port=6379,state=online,offset=36518,lag=0
master_failover_state:no-failover
master_replid:7edd6b310cda035a4eacac385c536581db72ffb8
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:36518
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:36518



# Replication
role:master
connected_slaves:2
slave0:ip=ds-redis-replicas-0.ds-redis-headless.redis-mr.svc.cluster.local,port=6379,state=online,offset=3814996,lag=1
slave1:ip=ds-redis-replicas-1.ds-redis-headless.redis-mr.svc.cluster.local,port=6379,state=online,offset=3814996,lag=1
master_failover_state:no-failover
master_replid:ecfd5f7a6a38d78db62747c204de7bb85ae0af32
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:3814996
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:2759401
repl_backlog_histlen:1055596


```

* role 확인
* slave IP 확인
* master_repl_offset
  * Primary의 replication offset



### info Commandstats

```sh
# 특정 항목 info
$ info commandstats
# Commandstats
cmdstat_replconf:calls=135851,usec=337258,usec_per_call=2.48,rejected_calls=0,failed_calls=0
cmdstat_psync:calls=2,usec=69,usec_per_call=34.50,rejected_calls=0,failed_calls=0
cmdstat_auth:calls=81874,usec=460936,usec_per_call=5.63,rejected_calls=0,failed_calls=0
cmdstat_command|docs:calls=6,usec=7471,usec_per_call=1245.17,rejected_calls=0,failed_calls=0
cmdstat_client|setinfo:calls=12,usec=15,usec_per_call=1.25,rejected_calls=0,failed_calls=0
cmdstat_ping:calls=81860,usec=127259,usec_per_call=1.55,rejected_calls=2,failed_calls=0
cmdstat_set:calls=120003,usec=345241,usec_per_call=2.88,rejected_calls=0,failed_calls=0
cmdstat_info:calls=9,usec=1435,usec_per_call=159.44,rejected_calls=0,failed_calls=0
cmdstat_get:calls=180014,usec=297290,usec_per_call=1.65,rejected_calls=0,failed_calls=0
cmdstat_select:calls=5,usec=7,usec_per_call=1.40,rejected_calls=0,failed_calls=0


```

* 명령어들의 통계정보 확인
* usec_per_call 을 확인한다.
* 1/100ms 단위이므로 만약 1이라면 초당 10만번 처리할 수 있는 속도임





### info Persistence

```sh
$ info persistence

# Persistence
loading:0
async_loading:0
current_cow_peak:0
current_cow_size:0
current_cow_size_age:0
current_fork_perc:0.00
current_save_keys_processed:0
current_save_keys_total:0
rdb_changes_since_last_save:3
rdb_bgsave_in_progress:0
rdb_last_save_time:1709907666
rdb_last_bgsave_status:ok
rdb_last_bgsave_time_sec:-1
rdb_current_bgsave_time_sec:-1
rdb_saves:0
rdb_last_cow_size:0
rdb_last_load_keys_expired:0
rdb_last_load_keys_loaded:1
aof_enabled:1
aof_rewrite_in_progress:0
aof_rewrite_scheduled:0
aof_last_rewrite_time_sec:0
aof_current_rewrite_time_sec:-1
aof_last_bgrewrite_status:ok
aof_rewrites:1
aof_rewrites_consecutive_failures:0
aof_last_write_status:ok
aof_last_cow_size:417792
module_fork_in_progress:0
module_fork_last_cow_size:0
aof_current_size:99
aof_base_size:99
aof_pending_rewrite:0
aof_buffer_length:0
aof_pending_bio_fsync:0
aof_delayed_fsync:0

```

* aof_enabled
  * AOF 기능이 활성화 되어있음을 나타냅니다.
* aof  rewrite
  * 특정 시점에 아래와 같은 사유로 AOF 파일 사이즈를 줄이는 rewrite 작업 수행함.
    * AOF 파일이 너무 커지면 OS 파일 사이즈 제한에 걸리거나, 
    * 서버 시작 시 AOF 파일을 로드하는 시간이 많이 소요
  * 파일 사이즈를 줄이는 매커니즘
    * 같은 Key 를 100번 수정하는 경우 AOF 에는 100번 수정한 내용이 모두 기록됨
    * rewrite 시 최종 수정된 마지막 값만 남긴다.
* aof_rewrite_in_progress
  * rewrite 가 진행여부 확인
* aof_rewrite_scheduled 
  * 진행중인 RDB 저장이 완료되면 AOF 다시 쓰기작업이 활성화
* aof_last_rewrite_time
  지난 번 rewrite 하는데 소요된 시간







# 5. ACL

Redis 6.0 이상부터는 계정별 access 수준을 정의할 수 있다.  

이러한 ACL 기능을 이용해서 아래와 같은 계정을 관리 할 수 있다.

- 읽기전용 계정 생성 가능

- 특정 프리픽스로 시작하는 Key 만 access 가능하도록 하는 계정 생성





## 1) Redis Client 확인

bastion Server 에서 Kubernetes redis access 테스트를 위해 Container redis client 를 설치하자.

```sh
## redis-client 용도로 docker client 를 실행한다.
$ docker run --name redis-client -d --rm --user root docker.io/redis:7.2 sleep 365d


## Container 확인
$ docker ps -a


## Docker Container 내에 진입후
$ docker exec -it redis-client bash

root@2ab11d7c8a62:/data#




## Local PC IP로 cluster mode 접근
$ redis-cli -h 43.201.82.244 -c -a new1234 -p 32300

43.201.82.244:32300>


```





## 2) ACL 기본명령

```sh



# 1) 계정 목록
43.201.82.244:32300> acl list
1) "user default on sanitize-payload #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~* &* +@all"


## 기본적으로 default 라는 계정이 존재한다.


# 2) 계정 추가
43.201.82.244:32300> acl setuser supersong on >new1234 allcommands allkeys
OK
43.201.82.244:32300> acl setuser tempsong on >new1234 allcommands allkeys
OK
43.201.82.244:32300>  acl list
1) "user default on sanitize-payload #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~* &* +@all"
2) "user supersong on sanitize-payload #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~* resetchannels +@all"
3) "user tempsong on sanitize-payload #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~* resetchannels +@all"



# 3) 계정 전환
43.201.82.244:32300> acl whoami
"default"
43.201.82.244:32300> auth supersong new1234
OK
43.201.82.244:32300> acl whoami
"supersong"
43.201.82.244:32300> auth default new1234
OK
43.201.82.244:32300> acl whoami
"default"



# 4) 계정 삭제
43.201.82.244:32300> acl deluser tempsong
(integer) 1
43.201.82.244:32300> acl list
1) "user default on #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~* &* +@all"
2) "user supersong on #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~* resetchannels +@all"

```





## 3) 읽기전용 계정 생성

- 읽기전용 계정 테스트

```sh

# 1) 읽기 계정 생성
43.201.82.244:32300> acl setuser readonlysong on >new1234 allcommands allkeys -set +get
OK
43.201.82.244:32300> acl list
1) "user default on #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~* &* +@all"
2) "user readonlysong on #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~* resetchannels +@all -set"
3) "user supersong on #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~* resetchannels +@all"




# 2) 계정 전환
43.201.82.244:32300> acl whoami
"default"
43.201.82.244:32300> auth readonlysong new1234
OK

43.201.82.244:32300> acl whoami
"readonlysong"



# 3) 읽기 / 쓰기 확인
43.201.82.244:32300> get a
"11"

43.201.82.244:32300> set a 1
(error) NOPERM this user has no permissions to run the 'set' command



# 4) 계정 전환
43.201.82.244:32300> auth default new1234
OK
43.201.82.244:32300> acl whoami
"default"


```





## 4) 특정 key만 접근 허용

- song으로 로그인 하면 song으로 시작하는 key 만 get/set 가능하도록 설정

```sh

# 1) song 으로 시작하는 key 만 접근가능한 User 새성
## 1-1) song 계정 생성
43.201.82.244:32300> acl setuser song on >new1234 allcommands allkeys
OK

43.201.82.244:32300> acl list
1) "user default on #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~* &* +@all"
2) "user readonlysong on #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~* resetchannels +@all -set"
3) "user song on #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~* resetchannels +@all"
4) "user supersong on #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~* resetchannels +@all"



## 1-2) song 으로 시작하는 key 만 접근가능도록 설정
43.201.82.244:32300> acl setuser song resetkeys ~song*
OK

43.201.82.244:32300> acl list
1) "user default on #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~* &* +@all"
2) "user readonlysong on #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~* resetchannels +@all -set"
3) "user song on #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~song* resetchannels +@all"
4) "user supersong on #65fd3b5c243ea857f91daef8e3d5c203fa045f33e034861998b9d74cc42ceb24 ~* resetchannels +@all"



# 2) 계정전환
43.201.82.244:32300> auth song new1234
OK

43.201.82.244:32300> acl whoami
"song"



# 3) set 명령 테스트
43.201.82.244:32300> set a 1
(error) NOPERM this user has no permissions to access one of the keys used as arguments

43.201.82.244:32300> set song:a 1
OK


# 4) get 명령 테스트
43.201.82.244:32300> get a
(error) NOPERM this user has no permissions to access one of the keys used as arguments

43.201.82.244:32300> get song:a
"1"



# 테스트 완료시
# Ctrl+D,   Ctrl+D 로   Exit 하자.
```






